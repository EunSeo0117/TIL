### 디자인 원칙

---

#### 1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.


- **상속 사용 시 문제점**
  - 서브클래스에서 코드 중복 발생
  - 실행 중 특징 변경이 어려움
  - 모든 서브클래스의 행동을 파악하기 어려움
  - 슈퍼클래스 코드 변경 시 의도치 않은 영향 발생
  - **즉, 규격이 유동적으로 변한다면 상속은 적합하지 않음**

- **인터페이스 사용 시 문제점**
  - 구현 코드가 없어 재사용 불가능
  - 행동 변경 시 모든 서브클래스를 찾아 수정 필요
  - 수정 과정에서 새로운 버그 발생 가능성 증가

- **디자인 패턴 활용**
  - 변경되는 부분을 캡슐화하여 분리
  - 의도치 않은 문제를 줄이고 시스템 유연성 확장
  - 변경되지 않는 부분에 영향을 주지 않고 수정 또는 확장 가능
  - **동적으로 행동 변경** 가능 (setter 사용)

---

#### 2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다.


- **인터페이스에 맞춘 프로그래밍**
  - 상위 형식(추상 클래스, 인터페이스)에 맞춰 프로그래밍
  - 객체가 코드에 고정되지 않도록 설계
  - 변수 선언 시 상위 형식을 사용하여 구체적인 객체 형식을 알 필요 없음

##### 예시 코드
```java
// 구현에 맞춘 프로그래밍
Dog d = new Dog();
d.bark();

// 인터페이스와 상위 형식에 맞춘 프로그래밍
Animal animal = new Dog();
animal.makeSound();

// 더 바람직한 방식
Animal a = getAnimal();
a.makeSound();
```
---

#### 3. 상속보다는 구성(composition)을 사용한다.
- **구성은 상속보다 낫다** (Composition over Inheritance)
- **"A에는 B가 있다"**라는 관계를 고려한 설계
- 클래스 A가 `doBehavior`라는 인터페이스를 사용하고, 이를 구현한 `do1`, `do2`가 존재할 경우:
  - A는 행동을 상속받지 않고, 적절한 행동 객체를 **구성(Composition)**하여 행동을 부여받음
- **구성(Composition)**이란 두 개의 클래스를 합쳐서 동작하도록 설계하는 방법
- 구성은 유연성을 크게 향상시키는 기술:
  - 알고리즘 군을 별도 클래스 집합으로 캡슐화 가능
  - 실행 시 **행동 변경** 가능
- **런타임에 동적인 행동 변경**을 지원
- 적용 가능한 디자인 패턴:
  - **전략 패턴 (Strategy Pattern)**
  - **데코레이터 패턴 (Decorator Pattern)**
  - **책임 연쇄 패턴 (Chain of Responsibility Pattern)**
---